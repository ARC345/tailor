<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vault</title>
    <link rel="stylesheet" href="frontend/theme.css">
    <!-- Icon Library -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* Minimal override for non-theme critical stuff if needed, otherwise empty */
    </style>
</head>

<body>
    <!-- App Container -->
    <div class="app-container">
        <!-- 1. Activity Bar -->
        <div id="activity-bar" class="activity-bar">
            <!-- Icons injected here -->
        </div>

        <!-- 2. Side Panel -->
        <div id="side-panel" class="side-panel" style="position:relative;">
            <div class="side-panel-header">
                <span id="side-panel-title">EXPLORER</span>
            </div>
            <div id="side-panel-content" class="side-panel-content">
                <!-- Content injected here -->
            </div>
            <div id="side-panel-resize" class="side-panel-resize"></div>
        </div>

        <!-- 3. Main Editor (GoldenLayout) -->
        <div class="main-editor">
            <div id="layout-root" style="width:100%; height:100%;"></div>
        </div>
    </div>

    <script type="module">
        import { GoldenLayout } from 'golden-layout';
        import 'golden-layout/dist/css/goldenlayout-base.css';
        import 'golden-layout/dist/css/themes/goldenlayout-dark-theme.css';

        // --- Sidebar Manager ---
        class SidebarManager {
            constructor() {
                this.views = new Map(); // id -> { icon, title, content }
                this.activeViewId = null;

                this.barEl = document.getElementById('activity-bar');
                this.panelEl = document.getElementById('side-panel');
                this.titleEl = document.getElementById('side-panel-title');
                this.contentEl = document.getElementById('side-panel-content');
            }

            registerView(id, iconData, title) {
                console.log(`[SidebarManager] Registering view: ${id}, icon: ${iconData}, title: ${title}`);

                if (this.views.has(id)) {
                    console.log(`[SidebarManager] View ${id} already registered, skipping`);
                    return;
                }

                this.views.set(id, { icon: iconData, title: title, content: '' });

                // Create Icon Button
                const btn = document.createElement('div');
                btn.className = 'activity-action';
                btn.title = title;
                btn.onclick = () => this.toggle(id);
                btn.dataset.id = id;

                // Check if iconData looks like an SVG string, otherwise assume it's a Lucide name
                if (iconData.trim().startsWith('<')) {
                    btn.innerHTML = iconData;
                    console.log(`[SidebarManager] Using raw SVG for ${id}`);
                } else {
                    // Lucide Icon name
                    btn.innerHTML = `<i data-lucide="${iconData}"></i>`;
                    console.log(`[SidebarManager] Using Lucide icon "${iconData}" for ${id}`);
                }

                this.barEl.appendChild(btn);
                console.log(`[SidebarManager] Button appended to activity bar`);

                // Initialize icons if Lucide is available
                if (window.lucide) {
                    window.lucide.createIcons();
                    console.log(`[SidebarManager] Lucide icons initialized`);
                } else {
                    console.warn(`[SidebarManager] Lucide not available!`);
                }
            }

            setContent(id, html) {
                if (this.views.has(id)) {
                    this.views.get(id).content = html;
                    // Update if active
                    if (this.activeViewId === id) {
                        this.contentEl.innerHTML = html;
                    }
                }
            }

            toggle(id) {
                if (this.activeViewId === id) {
                    // Close
                    this.activeViewId = null;
                    this.panelEl.classList.remove('open');
                    this._updateIcons();
                } else {
                    // Open
                    this.activeViewId = id;
                    const view = this.views.get(id);
                    this.titleEl.textContent = view.title;
                    this.contentEl.innerHTML = view.content || '<div style="padding:20px; text-align:center; color:var(--text-disabled)">Loading...</div>';
                    this.panelEl.classList.add('open');
                    this._updateIcons();

                    // Request content update from plugin if empty
                    if (!view.content) {
                        // Optional: Emit event to plugin to load data
                        // window.request('execute_command', { command: `${id}.get_sidebar` });
                    }
                }

                // Resize GoldenLayout after transition
                setTimeout(() => {
                    if (window.myLayout) window.myLayout.updateSize();
                }, 150);
            }

            _updateIcons() {
                const btns = this.barEl.querySelectorAll('.activity-action');
                btns.forEach(btn => {
                    if (btn.dataset.id === this.activeViewId) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });
            }
        }

        const sidebar = new SidebarManager();

        // Public API for Plugins
        window.ui = {
            registerSidebarView: (id, icon, title) => sidebar.registerView(id, icon, title),
            setSidebarContent: (id, html) => sidebar.setContent(id, html),
            toggleSidebar: (id) => sidebar.toggle(id)
        };

        // Sidebar views are registered dynamically by plugins via UI_COMMAND events

        // --- Resize Logic ---
        (function initResize() {
            const panel = document.getElementById('side-panel');
            const handle = document.getElementById('side-panel-resize');
            const mainEditor = document.querySelector('.main-editor');
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;

            handle.addEventListener('mousedown', (e) => {
                if (!panel.classList.contains('open')) return;
                isResizing = true;
                startX = e.clientX;
                startWidth = panel.offsetWidth;
                handle.classList.add('resizing');
                document.body.style.cursor = 'ew-resize';
                document.body.style.userSelect = 'none';

                // Prevent iframes from capturing mouse events during resize
                mainEditor.style.pointerEvents = 'none';

                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                const delta = e.clientX - startX;
                const newWidth = Math.max(150, Math.min(500, startWidth + delta));
                panel.style.width = newWidth + 'px';

                // Update GoldenLayout during resize for smoother experience
                if (window.myLayout) window.myLayout.updateSize();
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    handle.classList.remove('resizing');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';

                    // Re-enable pointer events on main editor
                    mainEditor.style.pointerEvents = '';

                    // Final GoldenLayout resize
                    if (window.myLayout) {
                        window.myLayout.updateSize();
                    }
                }
            });
        })();


        // --- Layout Config ---
        const config = {
            header: {
                popout: false
            },
            content: [{
                type: 'row',
                content: [
                    {
                        type: 'component',
                        componentName: 'stage',
                        title: 'Stage',
                        width: 65
                    },
                    {
                        type: 'column',
                        width: 35,
                        content: [
                            {
                                type: 'stack',
                                height: 40,
                                content: [
                                    {
                                        type: 'component',
                                        componentName: 'chat',
                                        title: 'LLM Chat'
                                    },
                                    {
                                        type: 'component',
                                        componentName: 'log',
                                        title: 'System Log'
                                    }
                                ]
                            },
                            {
                                type: 'component',
                                componentName: 'controls',
                                title: 'Inspector',
                                height: 20
                            }
                        ]
                    }
                ]
            }]
        };

        const myLayout = new GoldenLayout(config, document.getElementById('layout-root'));

        // --- Component Registration ---
        myLayout.registerComponent('stage', function (container, state) {
            container.element.innerHTML = `
                <div class="panel-container">
                    <div class="scrollable" id="plugin-area">
                        <!-- Default Plugin Area -->
                        <div style="color:var(--text-disabled); text-align:center; margin-top:50px;">
                            Stage Area
                        </div>
                    </div>
                </div>
            `;
        });

        myLayout.registerComponent('chat', function (container, state) {
            container.element.innerHTML = `
                <div class="panel-container">
                    <div class="scrollable" id="chat-area">
                        <div style="color:var(--text-disabled); text-align:center; padding-top:20px;">
                            Waiting for LLM...
                        </div>
                    </div>
                </div>
            `;
        });

        myLayout.registerComponent('log', function (container, state) {
            container.element.innerHTML = `
                <div class="panel-container">
                    <div class="scrollable" id="log-output"></div>
                    <div class="toolbar flex-between">
                        <span class="text-label" style="font-family:var(--font-main);">SYSTEM OUTPUT</span>
                        <button id="clearLog" class="icon-btn" title="Clear Log">
                            Clear
                        </button>
                    </div>
                </div>
            `;

            // Bind Clear Log
            const clearBtn = container.element.querySelector('#clearLog');
            if (clearBtn) {
                clearBtn.onclick = () => {
                    const out = document.getElementById('log-output');
                    if (out) out.innerHTML = '';
                };
            }
        });

        myLayout.registerComponent('controls', function (container, state) {
            container.element.innerHTML = `
                <div class="panel-container">
                    <div class="scrollable">
                        <label class="text-label" style="display:block; margin-bottom:4px; font-weight:600;">COMMAND INPUT</label>
                        <textarea id="cmd-input" rows="3" placeholder="demo.hello"></textarea>
                        
                        <label class="text-label" style="display:block; margin:8px 0 4px 0; font-weight:600;">ARGUMENTS (JSON)</label>
                        <input id="arg-input" placeholder='{"name": "User"}'>
                        
                        <button id="execBtn" class="btn btn-primary" style="width:100%; margin-top:12px;">Execute Command</button>
                    </div>
                </div>
            `;

            // Bind Execute
            const execBtn = container.element.querySelector('#execBtn');
            if (execBtn) {
                execBtn.onclick = async () => {
                    const cmd = document.getElementById('cmd-input').value;
                    let args = {};
                    try {
                        args = JSON.parse(document.getElementById('arg-input').value || '{}');
                        if (typeof args !== 'object' || args === null || Array.isArray(args)) {
                            throw new Error("Arguments must be a JSON object (e.g. {\"key\": \"value\"})");
                        }
                    } catch (e) {
                        log(`Invalid JSON args: ${e.message}`, 'error');
                        return;
                    }

                    try {
                        const res = await request('execute_command', { command: cmd, args: args });
                        log(JSON.stringify(res.result, null, 2));
                    } catch (e) {
                        log(`Exec failed: ${e}`, 'error');
                    }
                };
            }
        });

        myLayout.init();

        window.myLayout = myLayout; // Expose for debugging/resizing

        // Handle Resize
        window.addEventListener('resize', () => {
            if (myLayout.isInitialised) myLayout.updateSize();
        });


        // --- Logic Implementation ---

        let ws = null;
        let rpcId = 0;
        const pending = new Map();

        // Logging
        function log(msg, type = 'info') {
            const out = document.getElementById('log-output');
            if (!out) return;

            const div = document.createElement('div');
            div.className = `log-entry ${type}`;
            const time = new Date().toLocaleTimeString().split(' ')[0];
            div.innerHTML = `<span class="ts">${time}</span>${msg}`;
            out.appendChild(div);
            out.scrollTop = out.scrollHeight;
        }
        window.log = log; // Expose for plugins



        // Connection
        function setConnected(isConnected) {
            const indicator = document.getElementById('conn-status');

            if (isConnected) {
                // indicator.className = 'connected'; // Removed overlay, maybe show in activity bar later?
                log('Connected to Sidecar', 'in');

                // Wait for GoldenLayout to fully initialize and sidecar to be ready
                // Then load plugins with a longer delay
                setTimeout(() => {
                    log('Starting plugin load after delay...', 'info');
                    loadPlugins();
                }, 2000);  // 2 second delay for sidecar init
            } else {
                // indicator.className = 'disconnected';
                log('Disconnected', 'error');
            }
        }

        let reconnectAttempts = 0;
        const maxReconnectAttempts = 10;
        let currentPort = null;

        function connect(explicitPort) {
            // Priority: Explicit Arg > URL param > Default 9002
            let port = explicitPort || currentPort;
            if (!port) {
                const params = new URLSearchParams(window.location.search);
                port = params.get('port') || '9002';
            }
            currentPort = port;  // Save for reconnect

            log(`Connecting to ws://127.0.0.1:${port}... (attempt ${reconnectAttempts + 1}/${maxReconnectAttempts})`);

            ws = new WebSocket(`ws://127.0.0.1:${port}`);

            ws.onopen = () => {
                reconnectAttempts = 0;  // Reset on successful connect
                setConnected(true);
            };

            ws.onclose = () => {
                setConnected(false);
                scheduleReconnect();
            };

            ws.onerror = (e) => {
                log('WebSocket Error', 'error');
                // onclose will be called after onerror, which will trigger reconnect
            };

            ws.onmessage = (e) => {
                try {
                    const data = JSON.parse(e.data);
                    if (data.method === 'trigger_event') {
                        handleEvent(data.params);
                    } else if (data.id && pending.has(data.id)) {
                        pending.get(data.id)(data);
                        pending.delete(data.id);
                    }
                } catch (err) {
                    log(`Parse Error: ${err}`, 'error');
                }
            };
        }

        function scheduleReconnect() {
            if (reconnectAttempts >= maxReconnectAttempts) {
                log(`Max reconnect attempts (${maxReconnectAttempts}) reached. Please reload.`, 'error');
                return;
            }

            reconnectAttempts++;
            // Exponential backoff: 500ms, 1s, 2s, 4s... capped at 5s
            const delay = Math.min(500 * Math.pow(2, reconnectAttempts - 1), 5000);
            log(`Reconnecting in ${delay}ms...`, 'info');

            setTimeout(() => {
                connect();
            }, delay);
        }

        // RPC
        function request(method, params = {}) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                log('Not connected', 'error');
                return Promise.reject('Not connected');
            }
            return new Promise((resolve) => {
                const id = ++rpcId;
                const msg = { jsonrpc: '2.0', id, method, params };
                pending.set(id, resolve);
                ws.send(JSON.stringify(msg));
                log(`> ${method}`, 'out');
            });
        }
        window.request = request; // Expose for plugins

        // Plugin Loading with retry
        async function loadPlugins(retryCount = 0) {
            const maxRetries = 3;
            const retryDelay = 500; // ms

            try {
                // 0. Notify Backend Client is Ready (Triggers Plugin UI Registration)
                log('Notifying backend: system.client_ready', 'out');
                await request('system.client_ready', {})
                    .catch(e => console.warn('system.client_ready failed', e));

                // Wait for sidecar to finish initializing (longer on first attempt)
                const initDelay = retryCount === 0 ? 1000 : 300;
                await new Promise(resolve => setTimeout(resolve, initDelay));

                // 1. List Commands
                const res = await request('list_commands');
                log(`list_commands response: ${JSON.stringify(res).slice(0, 200)}`, 'in');

                const commands = res.result?.commands || {};
                const commandList = Object.keys(commands);
                log(`Available commands: ${commandList.length}`, 'info');

                // 2. Check for UI commands (convention: *.get_ui)
                const hasLLM = commandList.includes('llm.get_ui');
                log(`Has llm.get_ui: ${hasLLM}`, 'info');

                // If no commands yet and we have retries left, wait and retry
                if (commandList.length === 0 && retryCount < maxRetries) {
                    log(`No commands found, retrying in ${retryDelay}ms... (attempt ${retryCount + 1}/${maxRetries})`, 'info');
                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                    return loadPlugins(retryCount + 1);
                }

                if (hasLLM) {
                    log('Loading LLM UI...', 'out');
                    const uiRes = await request('execute_command', {
                        command: 'llm.get_ui',
                        args: {}
                    });

                    log(`llm.get_ui response: ${JSON.stringify(uiRes).slice(0, 300)}`, 'in');

                    // Handle various result structures
                    let html = null;

                    // Try different result paths
                    if (uiRes.result?.result?.html) {
                        html = uiRes.result.result.html;
                    } else if (uiRes.result?.html) {
                        html = uiRes.result.html;
                    } else if (uiRes.html) {
                        html = uiRes.html;
                    }

                    if (html) {
                        const stage = document.getElementById('chat-area');
                        if (!stage) {
                            log('Chat pane not found', 'error');
                            return;
                        }
                        // Use createContextualFragment to ensure scripts execute
                        const range = document.createRange();
                        range.selectNode(stage);
                        const fragment = range.createContextualFragment(`<div class="panel-container" style="height:100%;">${html}</div>`);
                        stage.innerHTML = '';
                        stage.appendChild(fragment);

                        // Re-initialize Lucide icons if present
                        if (window.lucide) {
                            window.lucide.createIcons();
                        }

                        log('Loaded LLM UI into Chat Pane', 'in');
                    } else {
                        log('No HTML in llm.get_ui response', 'error');
                    }
                } else if (!hasLLM && retryCount < maxRetries) {
                    // LLM plugin not found, retry
                    log(`LLM plugin not found, retrying... (attempt ${retryCount + 1}/${maxRetries})`, 'info');
                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                    return loadPlugins(retryCount + 1);
                } else {
                    // No LLM plugin after all retries, show default chat UI
                    const stage = document.getElementById('chat-area');
                    if (stage) {
                        stage.innerHTML = `
                            <div style="text-align:center; padding:40px; color:var(--text-disabled);">
                                <div style="font-size:2rem; margin-bottom:10px;">ðŸ’¬</div>
                                <p>LLM plugin not loaded</p>
                                <p style="font-size:0.8rem;">Enable the LLM plugin in .vault.json</p>
                            </div>
                        `;
                    }
                }

            } catch (e) {
                log(`Plugin Load Error: ${e}`, 'error');
                console.error('loadPlugins error:', e);

                // Retry on error
                if (retryCount < maxRetries) {
                    log(`Retrying after error... (attempt ${retryCount + 1}/${maxRetries})`, 'info');
                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                    return loadPlugins(retryCount + 1);
                }
            }
        }

        function handleEvent(evt) {
            log(`Event: ${evt.event_type}`, 'in');

            // Dispatch to window (plugins can listen)
            const eventType = evt.event_type; // e.g., 'LLM_RESPONSE'
            const detail = evt.data || {};

            const customEvent = new CustomEvent(eventType, { detail });
            window.dispatchEvent(customEvent);

            // Handle UI Commands from Backend
            if (eventType === 'UI_COMMAND') {
                console.log('[handleEvent] UI_COMMAND received:', evt.data);
                // Plugin requested UI action: { action: 'register_sidebar', id: '..', ... }
                const data = evt.data;
                if (data.action === 'register_sidebar') {
                    console.log('[handleEvent] Registering sidebar:', data.id, data.icon, data.title);
                    window.ui.registerSidebarView(data.id, data.icon, data.title);
                } else if (data.action === 'set_sidebar') {
                    console.log('[handleEvent] Setting sidebar content:', data.id);
                    window.ui.setSidebarContent(data.id, data.html);
                }
            }
        }

        // --- Auto-Connect Logic ---
        (async () => {
            let autoPort = null;

            // 1. Check URL Params (Robustness for new windows)
            const params = new URLSearchParams(window.location.search);
            if (params.has('port')) {
                autoPort = params.get('port');
                log(`Found port in URL: ${autoPort}`);
            }

            // 2. Try Tauri IPC (If launched via Tauri)
            if (!autoPort) {
                try {
                    const { invoke } = await import('@tauri-apps/api/core');
                    const vaultInfo = await invoke('get_current_vault_info');
                    if (vaultInfo && vaultInfo.ws_port) {
                        autoPort = vaultInfo.ws_port;
                        log(`Found port via Tauri: ${autoPort}`);
                    }
                } catch (e) {
                    // Not in Tauri or API failed
                }
            }

            if (autoPort) {
                // Delay slightly to ensure network is ready
                setTimeout(() => connect(autoPort), 300);
            } else {
                log('No auto-connect port found. Connection will use default (9002).');
                // Optional: Auto-connect to default if desired, or just wait
                setTimeout(() => connect('9002'), 300);
            }
        })();

    </script>
</body>

</html>